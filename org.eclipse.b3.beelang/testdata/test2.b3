/*
** syntax as of 24/10 2009 - experimental version 3
**
** A .b3 file
** consists of import statements followed by a single "unit". This is analogous with a .java file having imports
** and a single language element (class, interface).
**
** This file is a sampler used to test syntax. 
** The examples are not realistic (you will find plenty of a, b, c, fee and foo)
*/

/*
** COMMENTS
** Both single line and multi line comments are supported.
*/
	// Single line comment
	/* Multi line comment
	 */
	
/* 
** IMPORT
** Is used to import classes (just like in java). This is done so non qualified names can be used for classes
** DISCUSS: Imports are probably translated to meta requirements when resolving. As they are requirements on the environment.
** IMPLEMENTATION: The b3 'target platform' is probably constructed by registering packages/classes via extension points.
** It is not the intention to offer access to all java classes directly from b3 as this makes it virtually impossible to
** generate alternative execution from a b3 model. 
*/
//import org.eclipse.b3.default.Resolvers.*;

/*
** UNIT
** A Unit is a Build Unit. It is used for several purposes:
** - as a file that describes "top level" requirements (what to import into a workspace, repositories to use etc.)
** - as advice that extends meta data translation
** - as the meta data that describes a unit, when there is no other meta data
**
** THE UNIT DECLARATION
** -----
** PARALLEL or SEQUENTIAL
** A unit can optionally be marked as sequental or parallel (the default). Sequential means that requests 
** to its parts must be serialized. In addition, all execution is always synchronized - i.e. if parallel
** execution is in effect, two threads will never be able to evaluate a part at the same time. Sequential should
** therefore only be used when it is known that the unit/part invokes code that can not run in parallel with
** other things - example, a compiler that uses a fixed name for a tempfile, commands that alters the same file.
** IMPLEMENTATION NOTE: In is not required to run in parallel just because the unit is marked to support this.
**
** UNIT NAME
** The name of a unit is a qualified identifier (ID (. ID)*) where ID is an alphanumerical sequence that
** must start with "_" or a letter. If a name needs to contain any other character(s), it must be enclosed in
** " " - e.g. "Program Files".
**
** VERSION
** A Unit has a version, it can be entered without special quotes as a series of '.' separated segments where each
** segment is  (ID|(INT ID?)) - i.e. numerical, or alphanumerical. If a segment must contain something else, the
** version must be quoted within " ".
**
** IMPLEMENTS INTERFACES
** A unit can implement interfaces. These interfaces are "build time interfaces" and tells b3 about 
** parts it can expect to be present. This also helps an author of extended units, and 
** freshly created units comply with known build interfaces - i.e. making it possible to state that
** "this thing builds like an osgi.bundle" and get verification that this is true.
**
** THE UNIT BODY
** ----
** The unit body is enclosed in { }. Within in the Unit body, the following clauses are allowed:
** - Properties
** - Provided Capabilities
** - Required Capabilities (and Meta Required Capabilities)
** - Parts (analogous with members in a class).
** - Advice (Path/Predicate based access to elements that do not yet exist in the model). Used to set options, make
**	 overrides, etc.
** - Repositories - a configuration that is used to resolve (look up) units.
** - Synchronization - defines monitors across units that help solve issues in parallel builds
*/
sequential unit test version 2.3  implements osgi.bundle, eclipse.ecore.model {

	/* PROPERTIES 
	** Properties are one kind of variable in the b3 system. (The other kind is a local variable
	** used in scripted logic). Property names begin with $ and are followed by a qualified name
	** ID ('.' ID)* e.g. "$target.platform", "$a.b.c.d".
	** They can refer to simple data types like String, Integer, and Boolean, but also
	** Parts, Paths, etc.
	** Whenever properties are defined, they must be declared first in the context they appear.
	**
	** PROPERTY SET
	** The unit declaration allows a set of properties to be named. This makes it possible
	** to include an individual set of properties from an external build file.
	**
	** ABOUT PROPERTIES AS VARIABlES
	** By default properties are visible, but can be masked in downstream contexts. The keyword
	** 'immutable' makes it impossible to mask a property (nor can it be assigned), 
	** and the keyword 'unset' deletes the variable.
	** 
	** It is an error to initialize an immutable property to null.
	**
	** A previously declared (redeclareable) property can be restated as immutable. It is then
	** immutable in downstream contexts.
	**
	** EXPRESSIONS
	** b3 supports a large variety of JavaScript expressions that can be used to initialize properites.
	** Expressions are described in more detail below.
	** 
	** TYPED, UNTYPED, or SEMI_TYPED?
	** b3 (just as JavaScript) is untyped. This means that there is no need to type variables 
	** and automatic convertion will take place (in some cases) between types in order of generality. 
	** String is the most general, follwed by Integer, Boolean, and then all other types.
	** 
	** In operations of mixed type, the less general type is converted to the more general type before the operation takes
	** place. Thus "4" + 2 yields "42", and so does 4 + "2".
	**
	** Type conversion is possible via utility classes. A typical example is to make a file path out of a string, for instance
	** to check if a file exists e.g. Path("/Users/foo/bar.txt").exists(). 
	** IMPLEMENATATION NOTE: The conversion is performed using Eclipse adapt.
	**
	**
	** CONDITIONAL SETTING
	** Conditional declaration in b3 is done with a "when" clause on the form ('when' '(' Boolean Expression ')' )
	**    e.g. when(! $skipOptimization) $optimizeFlags = "";
	** Conditional property settings can be compound 
	**    e.g. when ($fullyOptimize) { $optimization=true; flags="-O4 -strip -useFpHw" }
	**
	** DISCUSS: Should there be an "else" clause?, and should we rename "when" to "if" ? The rationale for "else" is that
	** the same can be acheived by reversing the Boolean expression in the preceding when clause, but it puts the burden
	** on the developer. There is no harm in having an else clause if we allow a when/if clause.
	**
	** UNSET
	** Properties declared in a context can be unset (including immutable  properties).
	** This makes the same property from an outer scope visible (if it was visible before). It is an error to
	** unset a property declared in an upstream context e.g. unset $notDeclaredInThisContext.
	** DISCUSS: Should "unset" be called "delete" to comply with JS (it reduces the number of keywords).
	** 
	*/
	properties a {
		// a property can be initialized to null
		$foo = null;	
		immutable  $bar = 32;
		immutable  $bar = 32+10;
		$bar = "4" + 2;
		$bar = 4 + "2";
		$bar = $foo(10)[$a];
		$bar = 3[$a+$b];
		
		$foo = $XXX["a"]["b"];
		$foo = XXX[a["hello"]];
		$foo = ++$bar;
		$foo = ++$XXX.fee;
		$foo = $XXX.fee++;
		$foo = --$bar;
		$foo = "hello"++; // requires checking of datatype and operation
		$foo = ~/s/;
		
		// make the property "notPreviouslyImmutable" immutable in this context and
		// downstream. When returning from this scope, the property is again mutable.
		//
		immutable $notPreviouslyImmutable = $notPreviouslyImmutable;
		
		// checks if a calculation has the same value as a property
		immutable  $meaningful = 32+10 == $the.meaning.of.life;
		
		// a property can be "unset", that means that if it was set in this context, it will revert to
		// its value (if any) in an enclosing context.
		//
		unset  $yellow.banana;
	}
	// Several sets of properties can be declared, and they can be named. Named property sets can be 
	// included from other .b3 files.
	// 
	properties anIncludableSet {
		$bar = "bar";
		immutable $politician = "oxymoron";
		unset $yellow.banana;
		}
	
	// Properties can be conditionally set
	//
	properties {
		// for a single property statement
		when($a == $b) $b = $b + 1;		
		when($b == $b+1) $b = $b + 1;
		
		// for unset
		when($b == $c) unset $c;
		
		// and for a sequence of property statements	
		when($a == $b)
			{
			$a = 10;
			immutable $c = 20;//10;
			}
	}
	// Expression examples
	properties {
		$tmp = String.format("I am building for {0}, {1}",$target.platform, $target.ws);
		$path = Path($pathFromCommandLine);
		// note, that to call a method on a property, it must be enclosed in (), as
		// $a.b() is ambigous - call the function returned by $a.b, or an error
		$flag = ($path).hello(); 
		$flag = $var(fee);
	}
	
	/* PROVIDES
	** Provides clause is used to declare that the BuildUnit provides capabilities.
	** A capability consists of interface/unitname and an optional /version at the end.
	** If an interface, unitname or version requires use of reserved words or characters, the corresponding
	** part is entered as a string (i.e. within " ").
	** There is a compound provides clause if several capabilities are to be provided.
	** 
	** Provide Capabilities can be filtered - some capabilities may only be provided under certain circumstances.
	** This is declared with a leading when(BooleanExpression).
	*/
	provides osgi.bundle/bundlebar;
	provides osgi.bundle/bundlebar/1.0;
	provides {
		osgi.bundle/barbara.bundle/2.0;
		eclipse.feature/inflateable.pleasure/6.6.6;
			when(target.platform == platforms.win32) native.thing/windowsInstaller/12.23.r1234;
		}
	provides when(target.platform == platforms.win32)  native.thing/windowsInstaller/12.23.r1234;
	
	/* REQUIRES 
	** Requires clause is used to declare that the BuildUnit requires certain capabilities. 
	** The syntax differences between required and provided capabilities are that:
	** - the version is always a range (althoug a single version means >= version)
	*/
	requires osgi.bundle/air/1.0;
	requires when (!target.platform != "sparc" && target.platform < "hpUx") osgi.bundle/pillow/3.0 ;
	requires {
		osgi.bundle/pillow/1.0;
		when ($target.platform == "win32") osgi.bundle/blanket/1.0;
		osgi.bundle/magicstuff/[0.0.0.r0,5.r12345];
		}

	/* META REQUIRES 
	** With a leading 'meta' keyword, the requiremens are requirements on the environment (i.e. on b3 itself)
	** As an example, a meta requirement may be that a certain meta data provider is installed or it will be impossible to
	** use this definition. 
	*/
	meta requires x/y;
	meta requires osgi.bundle/air/[1.0,2.0);
	meta requires when (42 >= 32) osgi.bundle/pillow/3.0;
	// with odd version schemes in range
	// TODO: these versions are not valid Omni Versions - want more realistic examples.
	meta requires when (42 >= 32) java.jar/strangeAttractor/["alpha experiment 4", "release * 10b");
	meta requires {
		osgi.bundle/pillow/1.0;
		when (myorg.foo ~= "[a-z].*") osgi.bundle/blanket/1.0;
		}
	
	/* RETURNING ARTIFACTS
	** Artifact is a vector of path groups.
	** A group of paths may have a base path - the rest of the paths in the group are relative to the
	** base path.
	** File names that include reserved words or reserved characters are entered within " "
	** File names containing spaces must always be quoted, as the compiler removes whitespace from non strings.
	** Standard  XText implementation allows a unary ^ before a keyword as an escape (Remove?)
	** Inclusion of a vector can be controlled with a leading when(BooleanExpression).
	**
	** EXPRESSIONS
	** It is possible to evaluate an expression that results in a PathGroup and include the result in the list.
	**
	** VISIBILITY
	** Visibility is either private or public (the default). Private means that the part is only accesable
	** from within the b3 unit whene the part is declared.
	**
	** ANNOTATIONS
	** It is possible to set (and unset) annotations in the list using an 'annotations' statement.
	** The annotations are set on the resulting path group vector and are available to the user of the
	** set of files.
	** Since file group vectors are merged, so will the annotations. Use of immutable annotations will guarantee
	** that the annotation values set will surface (or an error will be generated if merging causes the value
	** to change), but is ok if multiple vectors are tagged the same way.
	**
	** DISCUSS: Does local annotation make sense? This would mean that the annotation is hidden when the result is merged.
	** It is a somwhat magical concept. 
	** 
	** Note that individual annotations per path is not supported. To flag an individual file it is
	** recommended to use dottiefied properties - example - mark the path /a/b as being little endian
	** property org.myorg.fileinfo.endian.a.b=little.
	**
	** PROVIDING CAPABILITIES
	** It is possible to declare that the resulting path group vector is a 'capability layed out on disk'.
	** They layout can represent many capabilities at the same time.
	**
	** ASSERTS
	** It is possibel to specify a series of postcondition asserts. An assert is a boolean expression, or
	** a call with boolean result. (It is not meaningful to have precondition on artifacts).
	**
	** DISCUSS - is it of value to have properties/annotations per file?
	** 
	*/
	private  "test.a1"  provides myorg.food/fruit.sallad/2.0, myorg.projectiles/fruit.salad
	postcondition { assert 2 > 1, "The integer evaluation is screwed up";
					assert SomeAssertProvider.checksumValidation("test.a1"), "Checksum failed"; 
					}
		{
		output{
		a; // a vector with one entry
		a, b; // a vector with two entries
		a [ b, c]; // a base path (a), with two relative paths in a vector
		"/a/b" ;
		"/a /b" ; // is equivalent to /a/b - not /" a"/" b"
		 
		
		// names that must be quoted
		"unit"; // a keyword
		"1a"; // does not look like a qualified name
		"a b"; // has space in name
		"aŒŠš"; // has NLS characters
		"//f"; // looks like a comment
		"123"; // is an integer
		
		"my.unit", "my.unit"; // unit is a keyword
		// feature removed: my.^unit; // unit is keyword - standard XText grammar escape of keywords in ID
		when(target.platform == "osx")  MacApp.app ;
		when(true) banana.txt, pineapple.txt, mango.txt;
		when (true) exotic [ rambustan.txt, tamarind.txt ];
		"a1" [apple.txt, "ban ana.txt"];
		"fee/apa.boo" [ "a/b/c.d", a.b.c.d, "o/b/d" ];
		
		when(thePopeHasAFunnyHat) 
			"/subpath" ["/Users/fred/buildstuff"]; 
			
		annotations { $monkey.food="banana"; $a=null; $b=null;}
		}
		return layout;
		}
	
	
	providesMany provides  a/b/1.0, c/d/2.0, x/y/3.0 { 
		output {
		lotsOfStuff;
		}
		return layout;
		}
	
	/* RETURNING GROUP
	** A group is similar to artifacts in that it creates a path group vector, but it creates this
	** by aggregating path group vectors from other parts. 
	** Just as with artifacts; the resulting path group vector can represent capabilities, and have annotations.
	**
	** The group consists of a list of required capabilities. The syntax is the same as for
	** the unit's requires { } clause, with the following additions:
	** - A trailing '#partname'  is used after the requirement to pick a particular part.
	** - A reference can be made to parts in the same build unit by using a single identifier
	** - A reference to a required capability without a trailing '#partname' is taken as a reference to '#self', meaning the
	**   aggregation of all its public parts.
	** - It is possible to define a closure where properties and advise are declared. They have downstream effect
	**   (i.e. when evaluating the part). The closure is defined using a trailing with { } statement.
	** - A closure can be defined for several requirements at the same time by enclosing the requirements in curly
	**   brackets {r r r} with { }
	** - A leading hidden keyword indicates that the resulting path group vector from the evaluation of the part should
	**   not be included in the resulting path group vector.
	** - The result of individual part evaluation, or evaluation of a group of requirements can be assigned to an alias.
	**   The alias is a property that is included in the resulting path group vector. This makes it possible for a user
	**   of the vector to reference a particular part of the set.
	** - hidden and alias can be used at the same time, but for a group that represents a part (as in this case), neither the
	**   property nor its value survive the group's context. For other types of grouping (in actions), this is very
	**   valuable, but in a group part, this construct simply has no effect. 
	** - an 'expr' entry allows inclusion of an expression that evaluates to a Part (i.e. the value type of a Part).
	**   
	** Advanced example:
	**     hidden a = someInterface/generator/1.0;
	**     expr Part(a):paths:exclude("org\.alienorg\..*");
	** This evaluates the part, but does not include it "as is" in the resulting PathGroup, instead, an alias is
	** used, which is passed to the Part utility where the paths are picked up and filtered.
	**
	** WITH CLOSURE
	** In the with closure, properties can be set using the single or compound properties statements.
	** Advice can be set using advice syntax.
	** 
	*/
	private parallel "foo/bar" provides  myorg.food/fruit.coctail/2.0, a / b / "2.3"
	precondition { assert 2 > 1, "Integer logic is flawed!"; }
	postcondition { assert 2 > 1, "Integer logic is flawed after the group was built!!!"; }
	{
	input {
	 	a; // referense to part in self
		foo/bar; // reference to #self in interface foo, name bar
		a/a#b; // reference to #b in interface a, name a
		fubbla= osgi.bundle/foo.bar/1.0; // sets the property fubbla to to the pathGroup reference in runtime - typically not used in groups
		osgi.bundle/fee.fum/1.0#jars;
		osgi.bundle/zeBundle/1.0#jars;
		hidden a/a#b; // only performed for side effect
		hidden aliasUno = b; // only performed for side effect, but sets a property to the result (that is then ignored)
		a/a#b with { properties { $nice = "yes"; }}; // sets and passes the property nice downsteam
		a/a#b with { // passes several properties downstream.
			properties {
				$a="2"; $b="2"; $c="3";
				}
			};
		// includes result of three references, all with the same set of downstream properties	
		{ a/a#b; a/b#c; a/c#d; } with { properties{ $target.platform="sparc"; }}; 
		// sets an alias on a non included result, result is a group of items with downstream properties
		hidden aliasedButNotIncluded = { a/a#b; a/b#c; a/c#d; } with { properties{ $foo="hpux";} };
		// sets an alias on an included item, result is a group of items with downstream properties, a nested alias is set
		aliasedAndIncluded = { aliasNbrThree=a/a#b; a/b#c; a/c#d; } with { properties {$foo="hpux"; }};
		
		// inclusion can be filtered with a boolean expression - here "true" makes it always included
		when (true) { a/a#b; a/b#c; a/c#d; } with { properties{ $foo="z80"; }};
		// filtering - here, never ever included because boolean value is false
		when (false) a/a#b;
		// a non included and filtered reference to a/a#b
		hidden when (true) a/a#b;
					
		// or, the shortest form
		hidden a = { a/b/1.0#x; c/d/2.0#x;};
		}
		return group;
	} 

	// The keyword 'sequential' declares that parallell execution of the part is dissallowed
	private sequential  foo { return null; }
	public sequential  foo { return null; }
	private  foo { return null;}
	foo {return null;}
	sequential foo { return null;}
	
		
	/*
	** ACTION
	** An action has a group declaration that defines the input to an actor. The actor is told to
	** produce a result based on this input (or sections thereof using aliases), the properties, and 
	** information describing the wanted layout of the result.
	**
	** The actor is declared in the preamble of the action part and is instantiated once.
	** Parameters to the actor instantiation can be passed with parentheses using named parameters
	** (order is not important).
	**
	** IMPLEMENTATION NOTE: Is it always possible to get the names of parameters in Java reflection?
	**
	** - An action can provide the resulting path group vector as provided capabilities
	**
	** Properties
	** Properties are declared first. The property values can then be used in the rest of the action's body.
	** 
	** Advice
	** The advice is applied after the properties have been set.
	**
	** Group
	** The group collects the result of evaluating each requirement. The collected result is available to the actor.
	** This includes collecting the annotations in each group. The annotations are also available to the actor.
	**
	** Aliases
	** Aliases for input parts have an additional meaning in actions as these properties are available to the actor.
	** A combination of hidden alias={ } can be used to feed special sections to the actor via symbolic names without having
	** to include the entire referenved group in the actor input. The use of additional alias is actor dependant and should
	** be specified in the actor's API.
	**
	** Layout
	** Layout clauses behave like artifacts parts, but they are descriptions of a wanted layout rather than references to
	** (pre) existing files. Typically a Layout describes the top elements, and any common "base paths".
	**
	** Annotations
	** It is possible to specify annotations in the layout clauses (the same way as annotations are done in
	** artifacts, or group clauses). The difference is that the actor may update non immutable annotations.
	** This means that an actor can pass information back (other than resulting files) - such as
	** a version qualifier, location of certain files on disk etc.
	**
	** You can think of annotations as properties that bubble upstream via the aggregation of a result from artifact
	** leaf nodes via groups and actions. Care has to be taken in naming these as all annotations are (potentially) placed
	** in the same scope when combinding parts.
	**
	** Annotations can be referenced via the Part utility, e.g. if you need a value to make decisions, naming locations
	** etc.
	**    a = sometype/somename#somepart;
	**    ...		
	**    layout {
	**        expr Part(adapt=a):annotation:org.myorg.revision [ a; b; c; ]
	** 
	*/
	private sequential  foo 
	provides  myorg.food/fruit.coctail/2.0
	precondition { assert 2 > 1, "Integer logic is flawed!"; }
	postcondition { assert 2 > 1, "Integer logic is flawed after the action was performed!!!"; }
	{
		properties { $a = $b; }
		input
			precondition { assert 2 > 1, "Integer logic is flawed!"; }
			postcondition { assert 2 > 1, "Integer logic is flawed after the group was evaluated!!!"; }
		{
			a; // defaults to #self
			when (apa > 11) a/a#b;
			osgi.bundle/foo.bar/"1.2.3.qualifier#,./"#jars; // defaults to #self
			
			
			osgi.bundle/fee.fum/1.0#jars;
			osgi.bundle/zeBundle#jars;
			hidden a/a#b; // only performed for side effect
			hidden aliasNbrOne = a/a#b; // only performed for side effect
			a/a#b with { properties{ $nice = "yes"; }};
			a/a#b with {
				properties {
					$a="2"; $b="2"; $c="3";
					}
				};
			{ a/a#b; a/b#c; a/c#d; } with { properties { $target.platform="sparc"; }};
			hidden { a/a#b; a/b#c; a/c#d; } with { properties { $foo="hpux"; }};
			hidden aliasNbrTwo = { aliasNbrThree=a/a#b; a/b#c; a/c#d; } with { properties{ $foo="hpux"; }};
			when (true) { a/a#b; a/b#c; a/c#d; } with { properties { $foo="z80"; }};
			when (false) a/a#b;
			hidden when (true) a/a#b;
			}
		output postcondition { assert 2 > 1, "Integer logic is flawed after the result was produced!!!"; }
		{	when(simpleA) a;
			when(advancedA) a/a; a/b;
			annotations { $revision="r101010"; } 
		}
		return SomeActor.doSomwthing(properties, group, layout);
	}
	test1 provides a/b/"1"
	{	// no dependencies, no special input, just "do it and produce result"
		return null;
	}
	test2  provides a/b/"1"
	{	// no dependencies, no special input, just "do it and produce result"
		// but set a property
		//
		properties{ $target.platform = "win32";}
		output { b.txt; }
		SomeActor.populateThisPlace(layout, properties);
	}

	test3 provides a/b/"1"
	{
		// group input with a specified wanted layout
		input { a; } 
		output { b.txt; }
		SomeActor.doSomething(group,layout);
	}
	test3 provides a/b/"1"
	{
		// group input with several specified layouts
		// that the actor knows how to handle.
		
		properties{ $docAndSourceRoot = "outputFolder";}
		input { a; } 
		output{ b.txt; }
		SomeActor.doSomething(group, layout,properties);
	}
	test4 provides a/b/"1"
	{
		// Pick different layout based on target platform
		input { a; } 
		
		output{ 
			when($target.platform =="win32")  b.exe; 
			when($target.platform =="macosx") b.app;
			when(!($target.platform =="macosx" || $target.platform=="win32")) b;
			}
		return SomeActor.doSomething(group, layout, properties);
	}

	WithAnnotations  {
		properties { $a = b; }
		advice { } 
		input { a; b; c;}
		output { a, b, c; base [x, y, z]; annotations{ $a = $a+$b;}}
		return SomeActor.doSomething(group, layout, properties);
	}

	
	/** Sequential clauses allows serialized execution to be specified across units/actions.
	** When executing a build in parallell, an engine should serialize the evaluation (build) of the
	** specified elements. Serialization of execution may serialize more than what is specified but never less.
	** Each synchronized list specifies a group that will be serialized. References are to part names in this unit, or
	** to part names in other units. 
	**
	** DISCUSS: although very useful, statements that synchronized on interface/*, and on actors are also useful.
	** Syntax should probably be xpath/query like.
	*/	
	sequential a,b,c;
	sequential a/a#x,b/b#x,c/c;
	
	sequential { a,b,c; d,e,f; } 
	
	/** REPOSITORIES
	** The repository clause defines the order in which repositories are searched.
	** There are two forms of entries - the most common is expected to be the short form, where
	** both the location, and repository type is specified with a URI. The URI scheme is used to select
	** a resolver. For cases where this is not possible, the longer form is to declare that a resolver should be
	** used, and the location (a general URL) is then set using advice (if indeed the selected resolver needs a location).
	** 
	** 
	*/
	repositories {
		 "http://bar/fee" { };
		 "http://bar/foo";
		 "http://bar/fum";
		 resolver foo.bar {
		 	// Statements here are advice relative to a resolver. (i.e. '.' is a resolver)
		 	// 
		 	location="http:://www.somewhere.com";
		 	apa = 10;
		 	booleanFlag = 10;
		 	options:advanced[featureA ~= "[a-z]*" ]:*[a>23]:b:** {
		 		option1 = 10;
		 		option2 = 20;
		 		option3 = "hello";
		 		};
		 	};
		 }
	advice import_This_Advice {
	    :requests[name~= ~/org.myorg\..*/g]:options {
	        source=true;
	        mutable=true;
	        };
	    :resolutions[name~= ~/org.eclipse\..*/g]:options {
	        location = "platform:/plugin/";
	        };
	}	 
}