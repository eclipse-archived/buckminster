grammar org.eclipse.b3.BeeLang // with org.eclipse.xtext.common.Terminals
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "platform:/resource/org.eclipse.b3.beelang/src/org/eclipse/b3/BeeLangTypes.ecore" as types
generate beeLang "http://www.eclipse.org/b3/BeeLang"

BeeModel hidden(WS, SL_COMMENT, ML_COMMENT): 
	(imports += Import)* 
	((functions+=Function) | (concern+=Concern))* 
	(body = Unit)? ;

Import : (reexport ?='reexport')? 
		'import' importer=(JavaImporter | NativeImporter) ("as" nameSpace=ID)? ';' 
	; 

JavaImporter 	: name=QID ;
NativeImporter 	: uriString = STRING ;
		
Unit returns BuildUnit hidden(WS, ML_COMMENT, SL_COMMENT) :
	(documentation = DOCUMENTATION)?
	(executionMode = ExecutionMode)?
	'unit' (name=UnitName)? ('version' version = Version)?
		('implements' implements += InterfaceName (',' implements+=InterfaceName)*)? 
	'{'
		(	//-- PROPERTIES
			// goes first, because they may be used in the other clauses.
			//
			  ('default' 'properties'  defaultProperties = PropertySet)
		)?
		( 	//-- PROVIDES
			  ('provides' '{' (providedCapabilities += ProvidedCapability ';')+ '}')
			| ('provides' providedCapabilities += ProvidedCapability ';')
			//-- REQUIRES & META REQUIRES
			| ('requires' '{' (requiredCapabilities += RequiredCapability ';')+ '}')
			| ('requires' requiredCapabilities += RequiredCapability ';')
			| ('env' 'requires' '{' (metaRequiredCapabilities += RequiredCapability ';')+ '}' )
			| ('env' 'requires' metaRequiredCapabilities += RequiredCapability ';')
			//--CONCERNS
			| (concerns+=Concern )
			//--SYNCHRONIZE
			| ('sequential' '{' (synchronizations += Synchronization )+  '}' )
			| ('sequential' synchronizations += Synchronization  )
			//--BUILD METHODS & FUNCTIONS
			| (builders += Builder )			
			| (methods += Method )			
			//-- REPOSITORIES
			| ('repositories' '{' (repositoryConfigurations+=RepositoryConfiguration)* '}' )
			| ('properties'  propertySets += NamedPropertySet)
			| ('containers' '{' containers += ContainerConfiguration* '}' )
		)*
	'}';
	

	
ProvidedCapability : capability=FilteredCapability  ('/' version=Version)?  ;
RequiredCapability : capability=FilteredCapability ('/' range=VersionRange)?  ;
FilteredCapability : ('when' filter=Filter)? capability = Capability ;
Capability : interface=InterfaceName '/' name=UnitName ;

// An optionally named sequence of property statements
NamedPropertySet returns NamedPropertySet
	: name = ID body = PropertySet 
	;

// Sequence of possibly filtered property statements	
PropertySet returns PropertySet
	:  ("extends" extends=[NamedPropertySet | QIDREF])? '{' (operations += PropertyOperation)* '}'
	;

// For model generation, to get supertype correct
PropertyOperation 
	: FilteredPropertyOperation 
	| SetPropertyOperation 
	| UnsetPropertyOperation 
	| PropertySet
	;

FilteredPropertyOperation returns FilteredPropertyOperation
	: 'when' filter=Filter
		body=(SetPropertyOperation | UnsetPropertyOperation | PropertySet) 
	;

SetPropertyOperation returns SetPropertyOperation
	: ( (final ?= 'final')? key=PropertyName op=AssignmentOperator value=Expression ';')
	;

UnsetPropertyOperation returns UnsetPropertyOperation
	: ('unset' key = PropertyName ';' )
	;

Synchronization 
	: (partrefs += SynchronizedPart)(',' partrefs += SynchronizedPart)+ ';' // at least 2
	;
	
SynchronizedPart
	: CompoundName ('#' PartName)?
	| PartName
	;
	
PathGroup : paths+=PathVectorElement+ ('annotations' annotations = PropertySet)? ;

PathVectorElement returns PathVectorElement
	: FilteredPathVector
	| BasePathVector
	| UnbasedPathVector
	;
	
FilteredPathVector returns FilteredPathVector 
	: 'when' filter=Filter body=(BasePathVector|UnbasedPathVector|CompoundPathVector) 
	;

BasePathVector returns PathVector
	: basePath=Path '[' ( paths+=Path (',' paths+=Path)*)? ']' ';'
	;

UnbasedPathVector returns PathVector
	: paths+=Path (',' paths+=Path)* ';'
	;
	
CompoundPathVector returns CompoundPathVector: '{' body+=PathVectorElement* '}' ;

// A path can be written without quotes if it consists of safe chars 
Path hidden()
	: STRING
	| ('/')? QID ('/' QID)* ('/')?  HIDDENBUG
	;

Prerequisite : 
		('when' filter=Filter )?
		(withClause = WithClause)?
		partReference=PrerequisiteEntry 
		("as" alias=ID)? ';'
	;

// Validation checks that there is at least one of references, properties or concern.
WithClause : {WithClause}
		'with'
		( '(' references += Expression (',' references += Expression)* ')' )? 
		(( 'properties' properties += PropertySet ) 
		| ( 'concern' concern += ConcernBlock ))*
		;
			
PrerequisiteEntry 
	: DirectPartReferemce
	| CapabilityReferencedPart
	| CompoundReferences
	;
	
DirectPartReferemce	: ((unit=QID)|(unit="unit"))? '#' builder=PartName  (parameters = ParameterList)?; 
	
CapabilityReferencedPart : 
	capability=Capability ('/' range=VersionRange)? ('#' partName=PartName) ?
	(parameters = ParameterList)?	 
	;
	
CompoundReferences
	: '{' (prerequisites += Prerequisite)* '}'
	;
	
Builder returns Builder : {Builder}
	(documentation = DOCUMENTATION)? 
	(visibility = Visibility)?
    (executionMode = ExecutionMode)?
  	(final ?= "final")?
	(cached ?= "cached")?
    "builder"
	name=PartName
	('(' params = ParameterDeclarationList ')')?
	('provides' providedCapabilities += ProvidedCapability (',' providedCapabilities += ProvidedCapability)*  )?
	(preCondition = PreCondition)?
	(postCondition = PostCondition)?
	 '{'
		('default' 'properties' properties = PropertySet)?
	     ( input = BuilderInput )? 
	     ( output = BuilderOutput )?
	     (expressionList = ExpressionList)?
	 '}'
	;

Parameter : (name = ID ':')? val = Expression ;
ParameterList : (params+=Parameter ("," params+=Parameter)* | params+=ClosureExpression)?;

ParameterDeclarationList : 
	( params += ParameterDeclaration (',' params+=ParameterDeclaration)*(',' params+=ParameterDeclarationEllipse)?) 
	| (params+= ParameterDeclarationEllipse)
	;
ParameterDeclaration : type=TypeRef? name = ID ;
ParameterDeclarationEllipse returns ParameterDeclaration : 
	{VarargParameterDeclaration} "..." (type=TypeRef)? name=ID
	;
 
InputKeyword : 'input' ; 
OutputKeyword : 'output'; 
	
BuilderOutput returns BuilderOutput
	: OutputKeyword '{' body = PathGroup '}' 
	;
	

BuilderInput
	: InputKeyword (preCondition = PreCondition)? (postCondition = PostCondition)?	 
		'{' (prerequisites += Prerequisite)+ '}'
	;

RepositoryConfiguration : RepositoryDeclaration | ResolutionStrategy ;

RepositoryDeclaration : 
	(documentation = DOCUMENTATION)?
	(location=URI | 'repository' type=TypeRef ) (context=ContextBlock)?
	;

ResolutionStrategy : 
	strategy = ("select-first" | "select-best") 
	'{' (repositoryConfig += RepositoryConfiguration)* '}'
	;

ContainerConfiguration : 
	(documentation=DOCUMENTATION)? 
	"container" name=ID "agent" type=TypeRef (contextBlock = ContextBlock)? 
	;
	
URI returns types::URI: STRING
	;

Concern : (documentation = DOCUMENTATION)? "concern" name=ID concern = ConcernBlock ;

ConcernBlock : 
	("extends" superConcerns+= ID (',' superConcerns += ID)*)? 
	'{' ((contexts+=Context) | (functions+=Function))* '}' 
	;

Query : "query" ('{' selector=QueryPath '}') ;	
QueryPath : (absolute?=':')? selectors+=Selector (':' selectors+=Selector)* ;
Selector returns Selector
	: (name=QID | op=SelectorOperator | pattern=REGEX) ('[' predicate=Expression ']')? 
	;
enum SelectorOperator : THIS = '.' | PARENT = '..' | CHILDREN = '*' | ANSCESTORS = '**' ;

Filter : '(' predicate = Expression ')' ;

PreCondition : "precondition" '{' (asserts += AssertionExpression)+ '}' ;
PostCondition : "postcondition" '{' (asserts += AssertionExpression)+ '}' ;
AssertionExpression : 'assert' expr=Expression ',' message=STRING ';' ;

ExpressionList : (expressions += Expression ';')+ ;

// Validation makes sure a Function is stated with "function", and Method with "method"
Function returns Function: {Function} func=FunctionOrMethod ;
Method returns Method: {Method} method=FunctionOrMethod ;

// Difference function/method handled as validation
FunctionOrMethod : 	
	(documentation = DOCUMENTATION)?
   	(visibility = Visibility)?
    (executionMode = ExecutionMode)?	   	
   	(final ?= "final")?
   	(cached ?= "cached")?
   	form=("function"|"method")
   	(type = TypeRef)?
   	name=ID 
   	( '<' typeParams+= TypeParamDeclaration (',' typeParams+=TypeParamDeclaration)* '>')?
   	('(' (params += ParameterDeclaration (',' params += ParameterDeclaration)*)? ')' )?
   	((':' body=Expression ';') | (body=BlockExpression))
	;
	
TypeParamDeclaration 
	: ID ( ("extends" type+= TypeRef ('&' type+=TypeRef)*) | ("super" superType=TypeRef))?
	;
		
/* EXPRESSIONS */
enum AssignmentOperator 
	: SET = '=' 		| SET_PLUS ='+='	| SET_MINUS ='-='		| SET_MUL='*='	| SET_DIV='/='
	| SET_MOD= "%=" 	| SET_AND = "&=" 	| SET_XOR = "^=" 		| SET_OR= "|=" 
	| SET_LSHIFT="<<=" 	| SET_RSHIFT=">>=" 	| SET_RSHIFT_0= ">>>=" 
	;
	
enum RelationalOperator 
	: EQ_MATCHES="~=" 	| EQ="==" 		| EQ_IDENTITY="==="	| EQ_NOT="!=" 	| EQ_NOT_IDENTITY="!=="
	| EQ_GTEQ=">=" 		| EQ_LEEQ="<=" 	| EQ_GT=">" 		| EQ_LT= "<"
	| EQ_INSTANCEOF="instanceof" 
	;

Expression returns Expression: AssignmentExpression | ReturnExpression;

ReturnExpression returns Expression : {ReturnExpression} "return" expr = AssignmentExpression ; 

AssignmentExpression returns Expression:
	 (OrExpression|VarDeclaration) ({AssignmentOperation.left=current} op=AssignmentOperator right=AssignmentExpression)?
	;

VarDeclaration returns Expression: {VarDeclaration} ('var' | type=TypeRef) name=ID ;

TypeRef : SimpleTypeRef | ClosureTypeRef;
SimpleTypeRef 
	: typeName+=ID ('::' typeName+=ID)* ('<' ruleTypeParameter+=RuleTypeParam (',' ruleTypeParameter+=RuleTypeParam)* '>' )? 
	;
// ClosureTypeRef declares parameters and return type	
ClosureTypeRef 
	: ( '(' parameterTypes+=TypeRef (',' parameterTypes+=TypeRef)* ')')? '=>' returnType = TypeRef
	;
	
RuleTypeParam : RuleTypeRefParam | WildcardRefParam ;
RuleTypeRefParam : TypeRef ;
WildcardRefParam : '?' ( ("extends" extends+=TypeRef (',' extends+=TypeRef)*) | "super" superRef=TypeRef )?;
	 
OrExpression returns Expression:
	AndExpression ({BooleanOperation.left=current} operator="||" right=AndExpression)*;
	
AndExpression returns Expression:
	BitwiseExpression ({BooleanOperation.left=current} operator="&&" right=BitwiseExpression)*;

BitwiseExpression returns Expression :
	RelationalExpression ({OperationCall.params+=current} name=("&" | "^" | "|") params+=RelationalExpression)*;
	
RelationalExpression returns Expression:
	ShiftExpression ({RelationalOperation.left=current} operator=RelationalOperator right=ShiftExpression)*;

ShiftExpression returns Expression:
	AdditiveExpression ({OperationCall.params+=current} name=("<<" | ">>" | ">>>") params+=AdditiveExpression)*;
	
AdditiveExpression returns Expression:
	MultiplicativeExpression ({OperationCall.params+=current} name=("+" | "-") params+=MultiplicativeExpression)*;

MultiplicativeExpression returns Expression:
	SetExpression ({OperationCall.params+=current} name=("*" | "/" | "%") params+=SetExpression)*;

enum SetOperator : SEQUENCE = '..' ;

SetExpression returns Expression:
	UnaryOrInfixExpression ({SetOperationCall.params+=current} op=SetOperator params+=UnaryOrInfixExpression)*;

UnaryOrInfixExpression returns Expression
	: UnaryExpression 
	| PostopExpression
	; 

UnaryExpression :
	 {UnaryOperation} name=("!" | "-" | "++" | "--" | "~") params+=PostopExpression;

PostopExpression returns Expression:
	InfixExpression ({OperationCall.postTarget=current} name = ("--" | "++"))?
	;

	
InfixExpression returns Expression:
	CallExpression ( 
	  	({OperationCall.target=current} "." name=ID  "(" parameters = ParameterList ")")
	  |	({AtCall.target=current} '[' index=Expression ']'
	  		("(" parameters = ParameterList ")")?) 	  
	  | ({FeatureCall.target=current} "." type=ID)
	)*;
	
CallExpression returns Expression: 
	PrimaryExpression ( 
		({OperationCall.target=current}"(" parameters = ParameterList ")"))*
		;
PrimaryExpression returns Expression
	: Literal 
	| FeatureCall 
	| ConstructorCallExpression
	| VariableValue
	| PropertyValue
	| KeywordVariables
	| ParanthesizedExpression
	| IfExpression
	| BlockExpression
	| SwitchExpression
	| ThrowExpression
	| TryCatchExpression
	| WildcardExpression
	| WithExpression
	;
	
WithExpression returns Expression: WithClauseExpression | WithContextExpression ;
WithClauseExpression returns Expression : {WithClauseExpression} 
	withclause=WithClause expr = BlockExpression 
	;
WithContextExpression returns Expresion : {WithContextExpression } 
	"with" "context" context = Expression expr = BlockExpression
	;
		
WildcardExpression returns Expression: {WildcardExpression} '_' ;

ThrowExpression returns Expression: {ThrowExpression} "throw"  expr=Expression ';' ;
TryCatchExpression : "try" tryBlock=Expression (catch+=CatchBlock)*
	(finally=FinallyBlock)? "endtry" 
	;
		
CatchBlock		: "catch" type = TypeRef var=ID ':' expr=Expression ;
FinallyBlock	: "finally" expr = Expression ;
SwitchExpression: "switch" switchExpr=Expression? (case+=Case)+  "endswitch" ;		
Case			: "case" condition=Expression ":" expr=Expression;

BlockExpression returns Expression: {BlockExpression} '{' (expr += Expression ';')* '}' ;

IfExpression returns Expression
	: {IfExpression} 'if'  cond=Expression "then" value=Expression 
	(tail += ElseIfExpression)*
	(tail += ElseExpression)?
	"endif"
	;

// for typing	
IfExpressionTail : ElseIfExpression | ElseExpression ;	
ElseIfExpression returns Expression: {ElseIfExpression} "elseif" condition=Expression "then" value=Expression ;
ElseExpression returns Expression: {ElseExpression} "else" value=Expression ;

PropertyValue returns  Expression: {PropertyValue} name = PID;
VariableValue returns  Expression: {VariableValue} name = ID ;
KeywordVariables returns  Expression: {KeywordVariable} 
	name = (InputKeyword | OutputKeyword | "properties" | "unit") ;

FeatureCall:
	OperationCall
	;
	
OperationCall returns OperationCall
	: name=(ID|PID) '(' (parameters = ParameterList)? ')' 
	| target= SuperLiteral '.' name=ID '(' (parameters = ParameterList)? ')'
	;

ConstructorCallExpression returns Expression
	: {CreatorCall} name="new" target=TypeRef ('(' (parameters=ParameterList)? ')')?
		("as" alias=ID)? (contextBlock = ContextBlock)?
	;

Context : "context" selector = ContextSelector block = ContextBlock ;
ContextSelector : TypeRefSelector | ExpressionSelector | UnitSelector ;
TypeRefSelector returns ContextSelector: type = TypeRef ;
ExpressionSelector : expr = Expression ;
UnitSelector : 
	"unit" interface=QID 
	('/' (name=UnitName | namePattern = REGEX) ('/' versionRange=VersionRange)? )? 
	;

ContextBlock : '{'  ((statements +=FunctionStatment) 
					| (statements+=BuilderStatement)
					| (statements+=ExpressionStatement)
					| (statements+=PropertiesStatement)
					)* '}' ;
					
ExpressionStatement returns Statement : {ExpressionStatement} val=Expression ';' ;
PropertiesStatement returns Statement : {PropertiesStatement} "properties" properties = NamedPropertySet ;
FunctionStatement returns Statement : {FunctionStatement} function = Function;
BuilderStatement returns Statement : {BuilderStatement} builder = Builder;

Literal returns Expression
	: ValueLiteral
	| RegexpLiteral
	| LiteralList
	| LiteralMap
	| LiteralFunction
	;
	
LiteralList returns  Expression
	: {LiteralList} '[' element += Expression (',' element += Expression)*  ']' ('<' type=TypeRef '>')?
	| {LiteralList} '[' ']' '<' type=TypeRef '>'
	;
LiteralMap returns  Expression
	: {LiteralMap} '[' features += Feature (',' features += Feature)* ']' ('<' keyType=TypeRef ',' valType=TypeRef '>')? 
	| {LiteralMap} '[' ']' '<' keyType=TypeRef ',' valType=TypeRef '>'
	;
LiteralFunction returns Expression: {LiteralFunction} '{' closure = ClosureExpression '}' ;

ClosureExpression : 
	(parameters += ParameterDeclaration (',' parameters += ParameterDeclaration)*)? '|' expr=Expression 
	;
	
Feature returns Feature: {Feature} name = (ID|PID|STRING) ':' value= Expression ;

ValueLiteral returns Expression
	: BooleanLiteral 
	| IntegerLiteral 
	| NullLiteral 
	| StringLiteral
	| RealLiteral
	| QueryLiteral
	| ThisLiteral
//	| SuperLiteral
	| UnitLiteral
	;
	
BooleanLiteral returns  Expression: {BooleanLiteral} val=("true" | "false");
IntegerLiteral returns  Expression: {IntegerLiteral} val= IntValue;
NullLiteral	returns  Expression: {NullLiteral} val="null";
ThisLiteral	returns  Expression: {ThisLiteral} val="this";
SuperLiteral returns  Expression: {SuperLiteral} val="super";
UnitLiteral returns  Expression: {UnitLiteral} val="unit";
StringLiteral returns  Expression: {StringLiteral} val = STRING;
RealLiteral	returns  Expression: {RealLiteral} val = RealValue;
RealValue returns ecore::EDouble: REAL ;
// handles dec, oct, and hex values with radix
IntValue returns types::RadixInteger: INT | HEX ;
RegexpLiteral returns Expression: {RegexpLiteral} val = REGEX;
QueryLiteral returns Expression: {QueryLiteral} val=Query ;
	
ParanthesizedExpression returns Expression
	:  "(" Expression ")"
	;	

Version : version = VersionLiteral;

VersionLiteral returns types::Version
	: STRING  
	| AlfanumSym
	;

/*
** VersionRange TODO: Uses two instances of Version. This works because use of [ ]  ( ) in Version must be 
** escaped with " ". Omni
** version uses version strings with \[ when a range is presented/parsed in string format.
*/
//VersionRange returns VersionRange
//	: minLimit=('[' | '(') min=Version (',' max=Version)? maxLimit=(']'|')')
//	| min=Version
//	;
VersionRange : range = VersionRangeLiteral ;

VersionRangeLiteral returns types::VersionRange 
	: ('[' | '(') (STRING | AlfanumSym) (',' (STRING | AlfanumSym))? (']'|')')
	| (STRING | AlfanumSym)
	;

// Reference to qualified named item, possibly in unit, this or super, or
// this.super, or unit.super
QIDREF : (("super" |(("unit" | "this") ('.' "super")?)) ('.' QID)?) | QID ;

// Qualified name
// TODO: Needs to disallow white space between ID and '.', and no embedded comments. 
// A bug in xtext prevents using hidden() here without the using the magic HIDDENBUG.
//
QID hidden(): ID (INT|HEX|ID)* ('.' ID (INT|HEX|ID)*)* HIDDENBUG;
HIDDENBUG hidden(WS, SL_COMMENT, ML_COMMENT): ('~~~~~')? ; // TODO: REPLACE HACK WHEN HIDDEN WORKS.

PropertyName : PID ;
EscapedQualifiedName:  STRING | QID;
InterfaceName: QID ;

// CompoundName (whitespace and comments allowed, as sequence can be very long. name parts
// do not allow being broken across lines.
//
CompoundName : EscapedQualifiedName '/' EscapedQualifiedName ;

// Aliases that help with unified naming (good for experiments - the indirection can be removed later)
UnitName : EscapedQualifiedName;
PartName : EscapedQualifiedName;

enum Visibility 	: public | private ;
enum ExecutionMode 	: parallel | sequential ;


// Version, and VersionRange
// TODO: uncertain if the set of allowed chars is definitive.
//
Separator : '.' | '-' | '!' | '@' | '$' | '%' | '&' |'+' | '=' | '*' | '<' | '>' | ':' | '?';
AlfanumSym : (ID | INT | HEX | EXT_INT) (Separator|ID|INT|HEX |EXT_INT)* ;

// --TERMINALS

// Redeclare the default ID with ï¿½ instead of ^ as escape mechanism
terminal ID : ('^')?(('a'..'z')|('A'..'Z')|'_') (('a'..'z')|('A'..'Z')|('0'..'9')|'_')* ;

// Property Names start with $ and are qualified. Must be handled by lexer as
// a.b.c is otherwise ambigous in expressions.
terminal PID : '$' ID ('.' ID)* ;

// JS Regexp
terminal REGEX returns types::RegularExpression
	: "~/" ( '\\' ('/'|'f'|'n'|'r'|'t'|'v'|'\\'|'.'|'*'|'+'|'?'
					| 'w'|'W'|'s'|'S'|'d'|'D'|'b'
					|'|'|'{'|'}'|'['|']'|'('|')'
					| (('0'..'7')('0'..'7')('0'..'7')) 
					| ('x' (('0'..'9')|('a'..'f')|('A'..'F')) (('0'..'9')|('a'..'f')|('A'..'F'))) 
					| ('c' ('A'..'Z'))
				)
			| (!('\\'|'/'|' '|'\t'|'\r'|'\n')))* "/" ('g'|'m'|'i')?
			;

// JS String support escaped b,t,n,f,r, and u HEX*4, x HEX*2, and (deprecated (0-7)), 
// A string converter may need to handle the u, x, and octal escapes.
// Regular java string handles XXXX , and gives syntax error if
// format is not ok, the other two remains, and possibly the null.
terminal STRING :
'"' ('\\'('b'|'t'|'n'|'f'|'r'|'u'|'x'|'0'|'"'|"'"|'\\') | !('\\'|'"'|'\r'|'\n') )* '"' |
"'" ('\\'('b'|'t'|'n'|'f'|'r'|'u'|'x'|'0'|'"'|"'"|'\\') | !('\\'|"'"|'\r'|'\n') )* "'";

terminal DOCUMENTATION : '/**' -> '*/' ;
terminal ML_COMMENT : '/*' (!'*') -> '*/' ;
terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')? ;
terminal WS : (' '|'\t'|'\r'|'\n')+ ;

// Uses special type to retain hex formatting.
terminal HEX : '0' ('x'|'X')(('0'..'9')|('a'..'f')|('A'..'F'))+ ;

//terminal REAL : ( ((('0'..'9') '.' ('0'..'9')) |('.' ('0'..'9'))) (('e'|'E')('-'|'+')INT)?) | (INT ('e'|'E')('-'|'+')INT) ;

//terminal REAL : (INT? '.' INT) (('e'|'E')('-'|'+')INT)? ;
terminal INT : ('0'..'9')+;
REAL hidden(): INT ? '.' (EXT_INT | INT) HIDDENBUG;
terminal EXT_INT: INT ('e'|'E')('-'|'+') INT;
 
//terminal REAL : ((INT '.' INT)|(INT '.')|('.' INT) | INT) (('e'|'E')('-'|'+')INT)? ;

terminal ANY_OTHER : . ;

